using System;
using System.Linq;
using System.Threading.Tasks;
using aska.core.common;
using aska.core.infrastructure.data.ef.Context;
using aska.core.infrastructure.data.mysql.Extensions;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using NLog;

namespace aska.core.infrastructure.data.mysql.Context
{
    public class BaseMysqlDbContext : DbContext, IDbContext, IMysqlDbContextExtendedOperations, IDbContextMigrate
    {
        private readonly IConnectionStringProvider _connectionStringProvider;
        private readonly IDbContextEntityTypesProvider _entityTypesProvider;

        /// <summary>
        /// 
        /// </summary>
        /// <example>
        /// connstring - "server=localhost;database=kovalevskaya_design;user id=kovalevskaya_design;password=kovalevskaya_design"
        /// </example>
        /// <param name="connectionStringProvider"></param>
        /// <param name="assembliesNamePrefix"></param>
        /// <param name="entityTypesProvider"></param>
        public BaseMysqlDbContext(
            IConnectionStringProvider connectionStringProvider, 
            IDbContextEntityTypesProvider entityTypesProvider) : base()
        {
            _connectionStringProvider = connectionStringProvider;
            _entityTypesProvider = entityTypesProvider;
        }
        
        
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            optionsBuilder.UseMySql(_connectionStringProvider.Get());

            // load model
            //AssemblyExtensions.ForceLoadAssemblies(Namespace.AssemblyNamePrefix);

            //var convention = new Microsoft.EntityFrameworkCore.Metadata.Conventions.ConventionSet();
            //var mb = new ModelBuilder(convention);
            //foreach (var definition in AssemblyExtensions.GetDerivedTypes<IEntity>(Namespace.AssemblyNamePrefix))
            //{
            //    mb.Entity(definition);
            //}
            //optionsBuilder.UseModel(mb.Model);

            //todo: causes NullReferenceException on creating initial migration (sdk 2.1.401)
        }
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            //modelBuilder.Entity<UserPrincipal>();
            //modelBuilder.Entity<ImageEntity>();
            //modelBuilder.Entity<ThematicPageEntity>();
            //modelBuilder.Entity<AttachmentEntity>();
            //modelBuilder.Entity<AttachmentConversionTask>();

            // I have an abstract base EntityMap class that maps Ids for my entities.
            // It is used as the base for all my class mappings
            //modelBuilder.Configurations.AddFromAssembly(typeof(EntityMap<>).Assembly);

            // identity models fix for mysql db
            // see: http://stackoverflow.com/questions/20832546/entity-framework-with-mysql-and-migrations-failing-because-max-key-length-is-76
            //modelBuilder.Entity<HistoryRow>().Property(h => h.MigrationId).HasMaxLength(100).IsRequired();
            //modelBuilder.Entity<HistoryRow>().HasKey(x => x.MigrationId);
            //modelBuilder.Entity<HistoryRow>().Property(h => h.ContextKey).HasMaxLength(200).IsRequired();

            
            // load all assemblies with entity classes before registering them
            //modelBuilder.RegisterTypes(_entityTypesProvider.Get());
            
            
            base.OnModelCreating(modelBuilder);
        }

        #region IDbContext implementation

        
        DbSet<T> IDbContext.GetDbSet<T>()
        {
            return base.Set<T>();
        }

        Task<int> IDbContext.SaveChangesAsync()
        {
            return base.SaveChangesAsync();
        }
        #endregion 

        #region mysql extended ops

        string IMysqlDbContextExtendedOperations.GetTableName<T>()
        {
            return GetTableName(typeof(T), this);
        }

        void IMysqlDbContextExtendedOperations.ExecuteRawSqlCommand(string command)
        {
            if (string.IsNullOrWhiteSpace(command)) throw new ArgumentOutOfRangeException(nameof(command));
            Database.ExecuteSqlCommand(command);
        }

        IQueryable<T> IMysqlDbContextExtendedOperations.ExecuteRawSqlQuery<T>(string query, params object[] parameters)
        {
            if (string.IsNullOrWhiteSpace(query)) throw new ArgumentOutOfRangeException(nameof(query));
            return Set<T>().FromSql(query, parameters);
        }
        
        void IMysqlDbContextExtendedOperations.TruncateTable<T>()
        {
            var tblName = GetTableName(typeof(T), this).ToLower();

            ////todo:  There is an issue with sql cmd parameters formatting. Using string.format as a workaround.
            var result = this.Database.ExecuteSqlCommand(string.Format("TRUNCATE `{0}`;", tblName));
        }

        /// <summary>
        /// returns the related table name, that has been generated by EF for requesing entity type  
        /// </summary>
        /// <param name="type">Entity type</param>
        /// <param name="context">DB Context</param>
        /// <returns></returns>
        private static string GetTableName(Type type, DbContext context)
        {
            var mapping = context.Model.FindEntityType(type).Relational();
            var schema = mapping.Schema;
            var tableName = mapping.TableName;
            return tableName;
        }
        #endregion
        
        #region migration

        string[] IDbContextMigrate.Migrate()
        {
            var pending = Database.GetPendingMigrations();
            Database.Migrate();
            return pending.ToArray();
        }
        #endregion
    }

}